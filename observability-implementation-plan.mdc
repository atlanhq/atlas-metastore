al# Atlas Observability Implementation Rules

## Overview
Implement comprehensive observability for Atlas `createOrUpdate` operations with detailed timing metrics, payload analysis, and dashboard visualization following the modern Micrometer-based approach used in `TaskMetricsService`.

## Core Requirements

### Dashboard Fields Required
- `trace_id` | `x-atlan-agent-id` | `x-atlan-client-origin` | `timestamp` | `duration`
- `payload_asset_size` | `payload_request_bytes` | `asset_guid` | `vertex_id`
- `array_relationship_counts` (JSON format: "operationType:relationshipName" -> count)
- `total_array_relationships` (sum of all array relationship counts)
- `array_attribute_counts` (JSON format: "attributeName" -> count)
- `total_array_attributes` (sum of all array attribute counts)
- `diffCalcTime` | `lineageCalcTime` | `validationTime` | `ingestionTime` | `notificationTime` | `auditLogTime`

## Implementation Phases

### Phase 1: Foundation & Data Model
- **New Class**: `AtlasObservabilityData` - Core data model for all observability metrics
- **New Class**: `AtlasObservabilityService` - Micrometer-based metrics collection (following `TaskMetricsService` pattern)
- **Modify**: `RequestContext` - Add observability data collection and trace correlation

#### AtlasObservabilityData Fields
- `traceId` - Request trace ID from AuditFilter
- `xAtlanAgentId` - Agent ID from request headers
- `xAtlanClientOrigin` - Client origin from request headers (e.g., "product_webapp", "playbook", "other")
- `timestamp` - Operation start time
- `duration` - Total operation duration
- `payloadAssetSize` - Number of entities in payload
- `payloadRequestBytes` - Serialized payload size
- `assetGuids` - List of entity GUIDs
- `vertexIds` - List of vertex IDs (for new entities)
- `arrayRelationshipCounts` - Map of relationship counts by operation type
- `totalArrayRelationships` - Sum of all array relationship counts
- `arrayAttributes` - Map of array attribute counts by attribute name
- `totalArrayAttributes` - Sum of all array attribute counts
- `diffCalcTime` - Time spent calculating differences
- `lineageCalcTime` - Time spent calculating lineage
- `validationTime` - Time spent on validation
- `ingestionTime` - Time spent on ingestion
- `notificationTime` - Time spent on notifications
- `auditLogTime` - Time spent on audit logging

### Phase 2: Payload Analysis & Asset Tracking
- **New Class**: `PayloadAnalyzer` - Analyze payload size and array relationships
- **Modify**: `AtlasEntityStoreV2.createOrUpdate()` - Main instrumentation point
- **Modify**: `preCreateOrUpdate()` - Capture vertex creation for new entities (lines 1852-1856)

#### Payload Analysis Requirements
- Calculate `payloadAssetSize` (count of entities in `AtlasEntitiesWithExtInfo`)
- Calculate `payloadRequestBytes` (serialized payload size)
- **Array Relationships Only**: Analyze `relationshipAttributes`, `appendRelationshipAttributes`, `removeRelationshipAttributes`
- For array relationships: log relationship name and count only
- Extract `assetGuids` and `vertexIds` for all top-level entities

#### New Entity Handling
- **Capture vertex creation** in `preCreateOrUpdate()` method:
  ```java
  // Create vertices which do not exist in the repository
  if (RequestContext.get().isImportInProgress() && AtlasTypeUtil.isAssignedGuid(entity.getGuid())) {
      vertex = entityGraphMapper.createVertexWithGuid(entity, entity.getGuid());
      // CAPTURE: New vertex created with assigned GUID
  } else {
      vertex = entityGraphMapper.createVertex(entity);
      // CAPTURE: New vertex created without GUID (will get generated)
  }
  ```
- Handle both assigned GUIDs and generated GUIDs
- Track vertex ID immediately after creation

### Phase 3: Timing Instrumentation
- **Modify**: `AtlasEntityComparator.getDiffResult()` - Track `diffCalcTime`
- **Modify**: Lineage methods in `EntityGraphMapper`:
  - `addHasLineage()` - track `lineageCalcTime`
  - `removeHasLineageOnDelete()` - track deletion lineage time
  - `resetHasLineageOnInputOutputDelete()` - track reset operations
- **Add**: Validation, ingestion, notification, and audit log timing

### Phase 4: Metrics Integration & Export
- **Extend**: `AtlasObservabilityService` with Micrometer integration
- **Configure**: `otel-config.yaml` for custom metrics and trace correlation
- **Setup**: Prometheus export for metrics collection

### Phase 5: Dashboard & Visualization
- **Create**: `atlas-observability-dashboard.json` for Grafana
- **Configure**: Alerting rules for performance thresholds
- **Implement**: Real-time monitoring capabilities

## Technical Architecture

### Key Classes to Create
- `AtlasObservabilityService` - Core metrics collection (Micrometer-based)
- `PayloadAnalyzer` - Payload size and array relationship analysis
- `AtlasObservabilityData` - Data model for observability metrics

### Key Classes to Modify
- `AtlasEntityStoreV2.createOrUpdate()` - Main instrumentation point
- `AtlasEntityComparator.getDiffResult()` - Diff timing
- `EntityGraphMapper` lineage methods - Lineage timing
- `AuditFilter` - Enhanced audit logging
- `RequestContext` - Observability data collection

### Metrics Framework
- **Use Micrometer** (following `TaskMetricsService` pattern)
- **Metric Types**: Counter, Timer, Gauge, DistributionSummary
- **Tagging**: tenant, operation, status, relationship type, client_origin
- **Percentiles**: 50th, 75th, 95th, 99th
- **SLOs**: Configurable performance thresholds

## Payload Analysis Specifications

### Array Relationship Analysis
- **Focus**: Only array-type relationships
- **Capture**: Relationship name and count
- **Operations**: `relationshipAttributes`, `appendRelationshipAttributes`, `removeRelationshipAttributes`
- **Format**: `"operationType:relationshipName" -> count`
- **Example**: `"relationshipAttributes:inputToProcess" -> 3`

### Array Attribute Analysis
- **Focus**: Array-type attributes (non-relationship arrays)
- **Capture**: Attribute name and count
- **Source**: `entity.getAttributes()` - regular entity attributes
- **Format**: `"attributeName" -> count`
- **Example**: `"columns" -> 5`, `"tags" -> 3`

### Asset Tracking
- **GUIDs**: Extract from `AtlasEntitiesWithExtInfo.entities`
- **Vertex IDs**: Capture during vertex creation
- **New Entities**: Track both assigned and generated GUIDs
- **Bulk Operations**: Handle mixed scenarios (new + existing entities)

### Request Context Data
- **Client Origin**: Extract from `RequestContext.getClientOrigin()` (already captured by AuditFilter)
- **Trace ID**: Extract from `RequestContext.getRequestId()` (already captured by AuditFilter)
- **Agent ID**: Extract from `RequestContext.getRequestContextHeaders().get("x-atlan-agent-id")`
- **Tenant ID**: Automatically added as metric attribute by infrastructure

## OpenTelemetry Integration
- **Extend**: `otel-config.yaml` for custom metrics
- **Enable**: Trace correlation across operations
- **Configure**: Metric export to Prometheus
- **Setup**: Structured logging for observability data

## Success Criteria
- All required dashboard fields captured and displayed
- Real-time monitoring of createOrUpdate operations
- Per-tenant performance analysis
- Comprehensive alerting system
- Minimal performance impact (<5% overhead)
- Complete trace correlation across operations

## Configuration Requirements
- **Atlas Properties**: Feature flags for enabling/disabling observability
- **Performance Tuning**: Configurable parameters for metrics collection
- **Tenant Support**: Per-tenant configurations
- **Retention Policies**: Data retention and cleanup

## Risk Mitigation
- **Performance Impact**: Implement async metrics collection
- **Data Volume**: Configure appropriate retention policies
- **Complexity**: Phased rollout with feature flags
- **Integration**: Thorough testing with existing systems