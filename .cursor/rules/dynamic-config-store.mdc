---
description: Dynamic Config Store - Cassandra-backed configuration system with in-memory cache and cross-pod refresh
alwaysApply: false
---
# Dynamic Config Store

## Module & Package Location

All Dynamic Config Store classes live in a **separate Maven module** (`atlas-config-store`):

```
config-store/src/main/java/org/apache/atlas/config/dynamic/
```

Maven artifact: `org.apache.atlas:atlas-config-store`
Package: `org.apache.atlas.config.dynamic`

**Important:** This module was extracted from `atlas-repository` into its own `config-store` module to avoid bloating the repository module. The package was previously at `org.apache.atlas.service.config`. Any new code referencing these classes MUST use the `org.apache.atlas.config.dynamic` package and add `atlas-config-store` as a Maven dependency.

## Core Classes

| Class | Purpose |
|-------|---------|
| `DynamicConfigStore` | Main coordinator - static API for get/set/delete configs, manages cache, coordinates with Cassandra |
| `DynamicConfigStoreConfig` | Loads configuration from `atlas-application.properties` (enabled, activated, keyspace, hostname, etc.) |
| `DynamicConfigCacheStore` | Thread-safe in-memory cache using `ConcurrentHashMap`, contains `ConfigEntry` inner class |
| `CassandraConfigDAO` | Singleton DAO for Cassandra persistence - schema init, CRUD with retry + exponential backoff |
| `ConfigCacheRefresher` | Cross-pod cache refresh via Kubernetes API pod discovery + HTTP calls |
| `ConfigKey` | Enum of valid config keys with default values (MAINTENANCE_MODE, ENABLE_JANUS_OPTIMISATION, etc.) |

## REST Endpoints

| File | Path | Purpose |
|------|------|---------|
| `webapp/.../web/rest/ConfigREST.java` | `/api/atlas/v2/configs` | CRUD REST API for dynamic configs |
| `webapp/.../web/rest/ConfigREST.java` | `/api/atlas/v2/configs/janus` | Read-only endpoint showing JanusGraph config from all layers (dynamic store, ApplicationProperties, defaults) |
| `webapp/.../web/rest/ConfigCacheRefreshREST.java` | `/api/atlas/admin/config` | Cache refresh endpoint called by other pods, maintenance mode status |

## Architecture

### Read/Write Flow

- **Reads** ALWAYS come from the in-memory `DynamicConfigCacheStore` (never hit Cassandra on read path)
- **Writes** update Cassandra first, then local cache, then refresh all other pods via `ConfigCacheRefresher`
- **Background sync** refreshes cache periodically from Cassandra

### Migration Strategy (Redis to Cassandra)

1. `enabled=true, activated=false` - Enables Cassandra connectivity; syncs feature flags from Redis to Cassandra; reads still fall back to Redis/configmap
2. `enabled=true, activated=true` - Cassandra is source of truth; reads come from Cassandra cache

### Feature Flag Helper Methods

`DynamicConfigStore` provides static helper methods that check `isActivated()`:
- `isTagV2Enabled()` - Falls back to `FeatureFlagStore.isTagV2Enabled()`
- `isMaintenanceModeEnabled()` - Falls back to `AtlasConfiguration.ATLAS_MAINTENANCE_MODE`
- `isPersonaHierarchyFilterEnabled()` - Falls back to `FeatureFlagStore.evaluate()`
- `useTempEsIndex()` - Falls back to `FeatureFlagStore.evaluate()`
- `getJanusCqlKeyspace()` - Falls back to `ApplicationProperties` (`atlas.graph.storage.cql.keyspace`), default: `atlas`
- `getJanusIndexName()` - Falls back to `ApplicationProperties` (`atlas.graph.index.search.index-name`), default: `janusgraph`

### JanusGraph Config Overrides

`AtlasJanusGraphDatabase.getConfiguration()` calls `DynamicConfigStore.getJanusCqlKeyspace()` and `DynamicConfigStore.getJanusIndexName()` directly. Since JanusGraph initializes before the Spring context is ready, `DynamicConfigStore.getInstance()` eagerly bootstraps itself (creates `DynamicConfigStoreConfig` + `DynamicConfigCacheStore` from `ApplicationProperties`, connects to Cassandra, loads cache) on first access. `CassandraConfigDAO.initialize()` is idempotent, so when Spring later creates the bean via `@PostConstruct`, it safely skips re-initialization and overrides `instance` with the fully-wired Spring bean.

Supported overrides:

| ConfigKey | ApplicationProperties fallback key | Default | Description |
|-----------|-----------------------------------|---------|-------------|
| `JANUS_CQL_KEYSPACE` | `atlas.graph.storage.cql.keyspace` | `atlas` | Cassandra keyspace used by JanusGraph |
| `JANUS_INDEX_NAME` | `atlas.graph.index.search.index-name` | `janusgraph` | Elasticsearch index name used by JanusGraph |

**Important:** These overrides only take effect at graph initialization time (JanusGraph is a singleton). Changing them at runtime via the REST API will NOT affect an already-running graph instance -- a pod restart is required.

## Consumer Files

These repository/webapp files import from `org.apache.atlas.config.dynamic`:

- `EntityGraphMapper.java`, `EntityMutationService.java`, `EntityGraphRetriever.java`
- `ClassificationTask.java`, `ClassificationPropagationTasks.java`, `ClassificationAssociator.java`
- `DeleteHandlerV1.java`, `SoftDeleteHandlerV1.java`
- `GraphHelper.java`, `ESAliasStore.java`, `AtlasEntityComparator.java`
- `TaskQueueWatcher.java`, `TaskExecutor.java`, `AtlasTaskService.java`
- `TagsV2AutoEnabler.java`
- `ActiveServerFilter.java`
- `ConfigREST.java`, `ConfigCacheRefreshREST.java`

## Configuration Properties

All properties are in `atlas-application.properties`:

| Property | Default | Description |
|----------|---------|-------------|
| `atlas.config.store.cassandra.enabled` | `false` | Enable/disable Cassandra config store |
| `atlas.config.store.cassandra.activated` | `false` | Use Cassandra for reads instead of Redis |
| `atlas.config.store.sync.interval.ms` | `60000` | Background sync interval (ms) |
| `atlas.config.store.cassandra.keyspace` | `config_store` | Cassandra keyspace |
| `atlas.config.store.cassandra.table` | `configs` | Cassandra table |
| `atlas.config.store.app.name` | `atlas` | Application name (partition key) |
| `atlas.config.store.cassandra.hostname` | falls back to `atlas.graph.storage.hostname` | Cassandra hostname |
| `atlas.config.store.cassandra.replication.factor` | `3` | Replication factor |
| `atlas.config.store.cassandra.datacenter` | `datacenter1` | Datacenter name |
| `atlas.config.store.cassandra.consistency.level` | `LOCAL_QUORUM` | Consistency level |

## Adding a New Config Key

1. Add enum value to `ConfigKey.java` with key string and default value
2. Optionally add a static helper method in `DynamicConfigStore` if it needs a Redis fallback
3. The key is immediately available via the REST API and `DynamicConfigStore.getConfig(key)`

## Code Patterns

### Reading a config value
```java
import org.apache.atlas.config.dynamic.DynamicConfigStore;

// Simple boolean check
boolean enabled = DynamicConfigStore.getConfigAsBoolean("MY_FLAG");

// String value
String value = DynamicConfigStore.getConfig("MY_KEY");

// Use helper methods when available (they handle Redis fallback)
boolean mmEnabled = DynamicConfigStore.isMaintenanceModeEnabled();
```

### Setting a config value
```java
DynamicConfigStore.setConfig("MY_KEY", "my_value", "updatedByUser");
```

## Spring Dependencies & Eager Initialization

- `DynamicConfigStore` depends on `featureFlagStore` (`@DependsOn("featureFlagStore")`)
- `DynamicConfigStoreConfig`, `DynamicConfigCacheStore`, `ConfigCacheRefresher` are all `@Component` beans
- `CassandraConfigDAO` is a manually-managed singleton (not a Spring bean), idempotent `initialize()`
- **Pre-Spring bootstrap:** `getInstance()` eagerly creates a `DynamicConfigStore` from `ApplicationProperties` when both `instance` and Spring `context` are null (needed for JanusGraph init). Spring's `@PostConstruct` later overrides `instance` with the fully-wired bean (including `ConfigCacheRefresher`).
