
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

name: Java CI with Maven

on:
  push:
    branches:
      - beta
      - master
      - staging
      - mlh-1477-staging
      - atlas_ci_cd_updates

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      # Set up Docker
      - name: Set up Docker
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: image=moby/buildkit:master
          install: true

      - name: Set up JDK 17
        uses: actions/setup-java@v1
        with:
          java-version: 17

      - name: Print JDK version
        run: java -version

      # Verify Docker is available
      - name: Verify Docker
        run: |
         docker --version
         docker info

      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/build.sh') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Get branch name
        run: |
          echo "BRANCH_NAME=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV
          echo BRANCH_NAME=${GITHUB_REF#refs/heads/}

      - name: Create Maven Settings
        uses: s4u/maven-settings-action@v2.8.0
        with:
          servers: |
            [{
                "id": "github",
                "username": "atlan-ci",
                "password": "${{ secrets.ORG_PAT_GITHUB }}"
            }]

      - name: Build with Maven
        run: |
          echo "build without dashboard"
          chmod +x ./build.sh && ./build.sh

      - name: Check disk space before tests
        id: check_disk
        run: |
          echo "=========================================="
          echo "DISK SPACE CHECK"
          echo "=========================================="
          df -h / | grep -E '^/dev/' || df -h / | tail -1
          echo ""
          
          # Get disk usage percentage (remove % sign)
          DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
          echo "Current disk usage: ${DISK_USAGE}%"
          echo "disk_usage=$DISK_USAGE" >> $GITHUB_OUTPUT
          
          if [ "$DISK_USAGE" -gt 70 ]; then
            echo "⚠️  Disk usage is high (${DISK_USAGE}%), cleanup will run"
          else
            echo "✅ Disk space is adequate (${DISK_USAGE}%), skipping cleanup"
          fi

      - name: Free up disk space for tests
        if: steps.check_disk.outputs.disk_usage > 70
        run: |
          echo "=========================================="
          echo "CLEANING UP DISK SPACE"
          echo "=========================================="
          
          # Clean Docker system
          echo "Cleaning Docker system..."
          docker system prune -af --volumes || true
          
          # Clean apt cache
          echo "Cleaning apt cache..."
          sudo apt-get clean || true
          sudo rm -rf /var/cache/apt/archives/* || true
          
          # Clean temp files
          echo "Cleaning temp files..."
          sudo rm -rf /tmp/* || true
          
          # Clean old GitHub Actions logs
          echo "Cleaning GitHub Actions logs..."
          sudo rm -rf /home/runner/work/_temp/_runner_file_commands/* || true
          
          # Clean hostedtoolcache if needed (keep essentials)
          echo "Cleaning hostedtoolcache (non-essential tools)..."
          sudo rm -rf /opt/hostedtoolcache/CodeQL || true
          sudo rm -rf /opt/hostedtoolcache/go || true
          sudo rm -rf /opt/hostedtoolcache/PyPy || true
          sudo rm -rf /opt/hostedtoolcache/node || true
          sudo rm -rf /opt/hostedtoolcache/Ruby || true
          
          echo ""
          echo "Disk space after cleanup:"
          df -h / | grep -E '^/dev/' || df -h / | tail -1

      - name: Verify sufficient disk space
        run: |
          echo "=========================================="
          echo "VERIFYING DISK SPACE"
          echo "=========================================="
          
          DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
          AVAILABLE_GB=$(df -h / | tail -1 | awk '{print $4}')
          
          echo "Current disk usage: ${DISK_USAGE}%"
          echo "Available space: ${AVAILABLE_GB}"
          
          # Fail if disk usage is still above 85%
          if [ "$DISK_USAGE" -gt 85 ]; then
            echo "ERROR: Insufficient disk space (${DISK_USAGE}% used)"
            echo "Tests require at least 15% free space to run reliably"
            echo "Elasticsearch will fail with high disk watermark errors at 90%+"
            exit 1
          else
            echo "Sufficient disk space available (${DISK_USAGE}% used)"
          fi

      - name: Run Integration Tests
        id: integration_tests
        continue-on-error: true
        env:
          # Configure Testcontainers for GitHub Actions
          TESTCONTAINERS_RYUK_DISABLED: true
          TESTCONTAINERS_CHECKS_DISABLE: true
          TESTCONTAINERS_REUSE_ENABLE: true  # Enable container reuse for atlan-java SDK tests
          DOCKER_HOST: unix:///var/run/docker.sock
        run: |
          echo "Running integration tests..."
          # Keep containers running for atlan-java SDK tests
          chmod +x ./run-integration-tests.sh && ./run-integration-tests.sh --keep-containers
      
      - name: Upload container logs as artifact
        if: always()  # Upload logs even if tests pass (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: container-logs-${{ github.run_id }}
          path: target/test-logs/
          retention-days: 5
      
      - name: Setup tmate session on test failure
        if: steps.integration_tests.outcome == 'failure'
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 30
        with:
          detached: true
          limit-access-to-actor: false
      
      - name: Fail the workflow if tests failed
        if: steps.integration_tests.outcome == 'failure'
        run: exit 1

      # ============================================================
      # Extended Integration Tests (atlan-java SDK)
      # Run additional SDK tests against the same testcontainers
      # ============================================================
      
      - name: Verify testcontainers are still running
        run: |
          echo "=========================================="
          echo "VERIFYING TESTCONTAINERS STATUS"
          echo "=========================================="
          
          # List running testcontainers (they have org.testcontainers label)
          echo "Running testcontainers:"
          docker ps --filter "label=org.testcontainers" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
          
          # Count testcontainers
          CONTAINER_COUNT=$(docker ps --filter "label=org.testcontainers" -q | wc -l | tr -d ' ')
          echo ""
          echo "Found $CONTAINER_COUNT testcontainers running"
          
          if [ "$CONTAINER_COUNT" -lt 5 ]; then
            echo "⚠️  Expected at least 5 containers (zookeeper, kafka, cassandra, elasticsearch, redis, atlas)"
            echo "Attempting to list all containers:"
            docker ps -a
          fi
          
          # Check if Atlas is accessible
          echo ""
          echo "Checking Atlas availability..."
          for i in {1..30}; do
            if curl -f -s -u admin:admin http://localhost:21000/api/atlas/admin/version > /dev/null 2>&1; then
              echo "✓ Atlas is accessible on port 21000"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Atlas is not accessible after 30 attempts"
              echo "Listing all containers for debugging:"
              docker ps -a
              exit 1
            fi
            echo "Waiting for Atlas... ($i/30)"
            sleep 2
          done
          
          echo "✓ Testcontainers are ready for atlan-java SDK tests"
      
      - name: Clone atlan-java repository
        run: |
          echo "=========================================="
          echo "CLONING ATLAN-JAVA REPOSITORY"
          echo "=========================================="
          git clone --depth 1 https://github.com/atlanhq/atlan-java.git /tmp/atlan-java
          echo "✓ Repository cloned to /tmp/atlan-java"
      
      - name: Set up JDK 21 for atlan-java tests
        uses: actions/setup-java@v1
        with:
          java-version: 21
      
      - name: Print Java version for atlan-java
        run: |
          echo "Java version for atlan-java tests:"
          java -version
      
      - name: Run atlan-java SDK integration test
        id: atlan_java_tests
        continue-on-error: true
        working-directory: /tmp/atlan-java
        env:
          # Use LOCAL mode - SDK will connect to http://localhost:21000
          ATLAN_BASE_URL: "LOCAL"
          # Basic Auth credentials (same as our integration tests)
          ATLAN_API_KEY: "admin:admin"
          # Disable checks that might interfere with testcontainers
          TESTCONTAINERS_RYUK_DISABLED: true
        run: |
          echo "=========================================="
          echo "RUNNING ATLAN-JAVA SDK TESTS"
          echo "=========================================="
          echo "Base URL: LOCAL (http://localhost:21000)"
          echo "Auth: Basic authentication (admin:admin)"
          echo ""
          
          # Run a single fundamental test - ConnectionTest
          echo "Running ConnectionTest..."
          ./gradlew test -PintegrationTests \
            --tests "com.atlan.java.sdk.ConnectionTest" \
            --info \
            --no-daemon
          
          echo "✓ atlan-java SDK test completed"
      
      - name: Upload atlan-java test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: atlan-java-test-results-${{ github.run_id }}
          path: |
            /tmp/atlan-java/integration-tests/build/reports/tests/
            /tmp/atlan-java/integration-tests/build/test-results/
            /tmp/atlan-java/integration-tests/*.log
          retention-days: 5
      
      - name: Check atlan-java test results
        if: steps.atlan_java_tests.outcome == 'failure'
        run: |
          echo "❌ atlan-java SDK tests failed"
          echo "Check the uploaded artifacts for detailed test reports"
          exit 1

      - name: Clean up after integration tests
        if: always()  # Always clean up, even if atlan-java tests fail
        run: |
          echo "=========================================="
          echo "CLEANING UP AFTER INTEGRATION TESTS"
          echo "=========================================="
          
          # Remove testcontainers that we kept running
          echo "Removing testcontainers..."
          TESTCONTAINER_IDS=$(docker ps -a --filter "label=org.testcontainers" -q)
          if [ -n "$TESTCONTAINER_IDS" ]; then
            echo "Found testcontainers to remove:"
            docker ps -a --filter "label=org.testcontainers" --format "table {{.Names}}\t{{.Status}}"
            docker rm -f $TESTCONTAINER_IDS || true
            echo "✓ Testcontainers removed"
          else
            echo "No testcontainers found to clean up"
          fi
          
          # Remove test containers and images
          echo ""
          echo "Removing other test containers and images..."
          docker system prune -af --volumes || true
          
          # Clean Maven artifacts to free up space
          echo "Cleaning Maven artifacts..."
          rm -rf ~/.m2/repository/org/apache/atlas/ || true
          
          # Clean test artifacts
          echo "Cleaning test artifacts..."
          rm -rf webapp/target/surefire-reports/ || true
          rm -rf test-debug-logs/ || true
          
          # Clean temp files
          echo "Cleaning temp files..."
          sudo rm -rf /tmp/* || true
          
          echo ""
          echo "Disk space after cleanup:"
          df -h / | tail -1

      - name: Get Repository Name
        run:   echo "REPOSITORY_NAME=`echo "$GITHUB_REPOSITORY" | awk -F / '{print $2}' | sed -e "s/:refs//"`" >> $GITHUB_ENV
        shell: bash

      - name: Get version tag
        # run: echo "##[set-output name=version;]$(echo `git ls-remote https://${{ secrets.ORG_PAT_GITHUB }}@github.com/atlanhq/${REPOSITORY_NAME}.git ${{ env.BRANCH_NAME }} | awk '{ print $1}' | cut -c1-7`)abcd"
        run: |
          echo "VERSION=$(git ls-remote https://${{ secrets.ORG_PAT_GITHUB }}@github.com/atlanhq/${REPOSITORY_NAME}.git ${{ env.BRANCH_NAME }} | awk '{ print $1}' | cut -c1-7 | head -n 1)abcd"
          echo "VERSION=$(git ls-remote https://${{ secrets.ORG_PAT_GITHUB }}@github.com/atlanhq/${REPOSITORY_NAME}.git ${{ env.BRANCH_NAME }} | awk '{ print $1}' | cut -c1-7 | tr -d '[:space:]')abcd"
          echo "VERSION=$(git ls-remote https://${{ secrets.ORG_PAT_GITHUB }}@github.com/atlanhq/${REPOSITORY_NAME}.git ${{ env.BRANCH_NAME }} | awk '{ print $1}' | cut -c1-7 | tr -d '[:space:]')abcd" >> $GITHUB_ENV

      - name: Get commit ID
        run: echo "COMMIT_ID=$(echo ${GITHUB_SHA} | cut -c1-7)abcd" >> $GITHUB_ENV

      # QEMU is required to build arm from a non-arm build machine
      - name: Set up QEMU
        id: qemu
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:qemu-v7.0.0-28
          platforms: arm64

      - name: Set up Buildx
        id: buildx
        uses: docker/setup-buildx-action@v1

      - name: Login to GitHub Registry
        uses: docker/login-action@v1
        with:
          registry: ghcr.io
          username: $GITHUB_ACTOR
          password: ${{ secrets.ORG_PAT_GITHUB }}

      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v3
        with:
          platforms: linux/amd64,linux/arm64
          context: .
          file: ./Dockerfile
          no-cache: true
          sbom: true
          provenance: true
          push: true
          tags: |
            ghcr.io/atlanhq/${{ github.event.repository.name }}-${{ env.BRANCH_NAME }}:latest
            ghcr.io/atlanhq/${{ github.event.repository.name }}-${{ env.BRANCH_NAME }}:${{ env.COMMIT_ID }}

      - name: Check Image Manifest
        run: docker buildx imagetools inspect --raw ghcr.io/atlanhq/${{ github.event.repository.name }}-${{ env.BRANCH_NAME }}:${{ env.COMMIT_ID }}

      - name: Scan Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'ghcr.io/atlanhq/${{ github.event.repository.name }}-${{ env.BRANCH_NAME }}:${{ env.COMMIT_ID }}'
          vuln-type: 'os,library'
          format: 'sarif'
          output: 'trivy-image-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2.1.33
        with:
          sarif_file: 'trivy-image-results.sarif'

  # Smoke test on vclusters (parallel with single VPN)

  smoke-test:
    name: Multi-Cloud Smoke Test
    needs: build
    runs-on: ubuntu-latest
    
    env:
      VCLUSTER_AWS_NAME: ${{ vars.VCLUSTER_AWS_NAME }}
      VCLUSTER_AZURE_NAME: ${{ vars.VCLUSTER_AZURE_NAME }}
      VCLUSTER_GCP_NAME: ${{ vars.VCLUSTER_GCP_NAME }}
      VCLUSTER_PROJECT: ${{ vars.VCLUSTER_PROJECT }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Get branch name
        run: echo "BRANCH_NAME=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV
      
      - name: Get commit ID
        run: echo "COMMIT_ID=$(echo ${GITHUB_SHA} | cut -c1-7)abcd" >> $GITHUB_ENV
      
      - name: Set test image
        run: echo "TEST_IMAGE=ghcr.io/atlanhq/${{ github.event.repository.name }}-${{ env.BRANCH_NAME }}:${{ env.COMMIT_ID }}" >> $GITHUB_ENV
      
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Install vCluster CLI
        uses: loft-sh/setup-vcluster@main
      
      - name: Install jq
        run: sudo apt-get install -y jq
      
      - name: Connect to GlobalProtect VPN
        env:
          VCLUSTER_PLATFORM_URL: ${{ secrets.VCLUSTER_PLATFORM_URL }}
        run: |
          echo "=================================================="
          echo "CONNECTING TO VPN (Shared for all clouds)"
          echo "=================================================="
          
          # Install OpenConnect
          sudo apt-get update -qq
          sudo apt-get install -y openconnect
          
          # Connect to VPN (using default DTLS/ESP for AWS compatibility)
          echo "${{ secrets.GLOBALPROTECT_PASSWORD }}" | sudo openconnect \
            --protocol=gp \
            --user="${{ secrets.GLOBALPROTECT_USERNAME }}" \
            --passwd-on-stdin \
            --background \
            "${{ vars.GLOBALPROTECT_PORTAL_URL }}"
          
          # Wait for connection to establish
          echo "Waiting for VPN connection to stabilize..."
          sleep 20
          
          # Check if VPN is running
          if ! pgrep -x openconnect > /dev/null; then
            echo "ERROR: OpenConnect exited unexpectedly"
            exit 1
          fi
          echo "VPN process is running (PID: $(pgrep -x openconnect))"
          
          # Configure routing for vCluster Platform (172.17.0.0/16)
          VPN_INTERFACE=$(ip addr show | grep -E '^[0-9]+: tun' | head -1 | cut -d: -f2 | tr -d ' ' || echo "tun0")
          echo "Using VPN interface: $VPN_INTERFACE"
          
          sudo ip route del 172.17.0.0/16 dev docker0 2>/dev/null || true
          sudo ip route add 172.17.0.0/16 dev $VPN_INTERFACE
          
          # Verify connectivity
          if curl -k -sS $VCLUSTER_PLATFORM_URL -o /dev/null --max-time 30; then
            echo "✓ VPN connected successfully"
          else
            echo "ERROR: VPN connectivity test failed"
            exit 1
          fi
      
      - name: Login to vCluster Platform
        env:
          VCLUSTER_PLATFORM_URL: ${{ secrets.VCLUSTER_PLATFORM_URL }}
          VCLUSTER_ACCESS_KEY: ${{ secrets.VCLUSTER_ACCESS_KEY }}
        run: |
          echo "=================================================="
          echo "LOGGING IN TO VCLUSTER PLATFORM (Shared)"
          echo "=================================================="
          vcluster platform login $VCLUSTER_PLATFORM_URL --access-key $VCLUSTER_ACCESS_KEY
          echo "✓ Login successful"
      
      - name: Connect to all vClusters
        run: |
          echo "=================================================="
          echo "CONNECTING TO ALL VCLUSTERS"
          echo "=================================================="
          
          # Connect to AWS vCluster
          echo "Connecting to AWS vCluster ($VCLUSTER_AWS_NAME)..."
          KUBECONFIG=kubeconfig-aws.yaml vcluster platform connect vcluster $VCLUSTER_AWS_NAME --project $VCLUSTER_PROJECT
          echo "✓ AWS kubeconfig saved to kubeconfig-aws.yaml"
          
          # Connect to Azure vCluster  
          echo "Connecting to Azure vCluster ($VCLUSTER_AZURE_NAME)..."
          KUBECONFIG=kubeconfig-azure.yaml vcluster platform connect vcluster $VCLUSTER_AZURE_NAME --project $VCLUSTER_PROJECT
          echo "✓ Azure kubeconfig saved to kubeconfig-azure.yaml"
          
          # Connect to GCP vCluster  
          echo "Connecting to GCP vCluster ($VCLUSTER_GCP_NAME)..."
          KUBECONFIG=kubeconfig-gcp.yaml vcluster platform connect vcluster $VCLUSTER_GCP_NAME --project $VCLUSTER_PROJECT
          echo "✓ GCP kubeconfig saved to kubeconfig-gcp.yaml"
          
          echo ""
          echo "Verifying kubeconfigs..."
          ls -lh kubeconfig-*.yaml
          
          echo ""
          echo "Testing AWS connection..."
          KUBECONFIG=kubeconfig-aws.yaml kubectl cluster-info | head -1
          
          echo ""
          echo "Testing Azure connection..."
          KUBECONFIG=kubeconfig-azure.yaml kubectl cluster-info | head -1
          
          echo ""
          echo "Testing GCP connection..."
          KUBECONFIG=kubeconfig-gcp.yaml kubectl cluster-info | head -1
          
          echo ""
          echo "✓ All vCluster connections established"
      
      - name: Run parallel smoke tests
        run: ./scripts/multi-cloud-smoke-test.sh ${{ env.TEST_IMAGE }}
      
      - name: Upload smoke test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-logs-${{ github.run_id }}
          path: smoke-test-logs/
